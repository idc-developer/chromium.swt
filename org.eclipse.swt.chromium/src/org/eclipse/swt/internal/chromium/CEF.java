/* automatically generated by rust-bindgen */

package org.eclipse.swt.internal.chromium;

import static org.eclipse.swt.internal.chromium.CEFFactory.mapTypeForClosure;

import jnr.ffi.*;
import jnr.ffi.annotations.*;
import jnr.ffi.byref.*;
import org.eclipse.swt.internal.chromium.CEFFactory.cef_base_ref_counted_t;
import jnr.ffi.util.EnumMapper.IntegerEnum;

public class CEF {
  public static class cef_string_utf16_t extends Struct {
    static {
      mapTypeForClosure(cef_string_utf16_t.class);
    }

    public Pointer str = new Pointer();
    public UnsignedLong length = new UnsignedLong();
    public Function<dtor> dtor = function(dtor.class);

    public static interface dtor {
      @Delegate
      void invoke(jnr.ffi.Pointer str);
    }

    public cef_string_utf16_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }

  public static class cef_string_userfree_utf16_t extends cef_string_utf16_t {
    public cef_string_userfree_utf16_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }

  public static class cef_string_userfree_t extends cef_string_userfree_utf16_t {
    public cef_string_userfree_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }

  public static class cef_string_t extends cef_string_utf16_t {
    public cef_string_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Time information. Values should always be in UTC.
  ///
  public static class cef_time_t extends Struct {
    static {
      mapTypeForClosure(cef_time_t.class);
    }
    /// Four or five digit year "2007" (1601 to 30827 on
    /// Windows, 1970 to 2038 on 32-bit POSIX)
    public Signed32 year = new Signed32();
    /// 1-based month (values 1 = January, etc.)
    public Signed32 month = new Signed32();
    /// 0-based day of week (0 = Sunday, etc.)
    public Signed32 day_of_week = new Signed32();
    /// 1-based day of month (1-31)
    public Signed32 day_of_month = new Signed32();
    /// Hour within the current day (0-23)
    public Signed32 hour = new Signed32();
    /// Minute within the current hour (0-59)
    public Signed32 minute = new Signed32();
    /// Second within the current minute (0-59 plus leap
    /// seconds which may take it up to 60).
    public Signed32 second = new Signed32();
    /// Milliseconds within the current second (0-999)
    public Signed32 millisecond = new Signed32();

    public cef_time_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }

  public enum cef_return_value_t implements IntegerEnum {
    RV_CANCEL(0x0),
    RV_CONTINUE(0x1),
    RV_CONTINUE_ASYNC(0x2),
    ;
    private int nativeInt;

    private cef_return_value_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }
  ///
  /// Cookie information.
  ///
  public static class cef_cookie_t extends Struct {
    static {
      mapTypeForClosure(cef_cookie_t.class);
    }
    ///
    /// The cookie name.
    ///
    public cef_string_t name = inner(new cef_string_t(getRuntime()));
    ///
    /// The cookie value.
    ///
    public cef_string_t value = inner(new cef_string_t(getRuntime()));
    ///
    /// If |domain| is empty a host cookie will be created instead of a domain
    /// cookie. Domain cookies are stored with a leading "." and are visible to
    /// sub-domains whereas host cookies are not.
    ///
    public cef_string_t domain = inner(new cef_string_t(getRuntime()));
    ///
    /// If |path| is non-empty only URLs at or below the path will get the cookie
    /// value.
    ///
    public cef_string_t path = inner(new cef_string_t(getRuntime()));
    ///
    /// If |secure| is true the cookie will only be sent for HTTPS requests.
    ///
    public Signed32 secure = new Signed32();
    ///
    /// If |httponly| is true the cookie will only be sent for HTTP requests.
    ///
    public Signed32 httponly = new Signed32();
    ///
    /// The cookie creation date. This is automatically populated by the system on
    /// cookie creation.
    ///
    public cef_time_t creation = inner(new cef_time_t(getRuntime()));
    ///
    /// The cookie last access date. This is automatically populated by the system
    /// on access.
    ///
    public cef_time_t last_access = inner(new cef_time_t(getRuntime()));
    ///
    /// The cookie expiration date is only valid if |has_expires| is true.
    ///
    public Signed32 has_expires = new Signed32();
    public cef_time_t expires = inner(new cef_time_t(getRuntime()));

    public cef_cookie_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }

  public enum cef_termination_status_t implements IntegerEnum {
    TS_ABNORMAL_TERMINATION(0x0),
    TS_PROCESS_WAS_KILLED(0x1),
    TS_PROCESS_CRASHED(0x2),
    ;
    private int nativeInt;

    private cef_termination_status_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }

  public enum cef_errorcode_t implements IntegerEnum {
    ERR_NONE(0),
    ERR_FAILED(-2),
    ERR_ABORTED(-3),
    ERR_INVALID_ARGUMENT(-4),
    ERR_INVALID_HANDLE(-5),
    ERR_FILE_NOT_FOUND(-6),
    ERR_TIMED_OUT(-7),
    ERR_FILE_TOO_BIG(-8),
    ERR_UNEXPECTED(-9),
    ERR_ACCESS_DENIED(-10),
    ERR_NOT_IMPLEMENTED(-11),
    ERR_CONNECTION_CLOSED(-100),
    ERR_CONNECTION_RESET(-101),
    ERR_CONNECTION_REFUSED(-102),
    ERR_CONNECTION_ABORTED(-103),
    ERR_CONNECTION_FAILED(-104),
    ERR_NAME_NOT_RESOLVED(-105),
    ERR_INTERNET_DISCONNECTED(-106),
    ERR_SSL_PROTOCOL_ERROR(-107),
    ERR_ADDRESS_INVALID(-108),
    ERR_ADDRESS_UNREACHABLE(-109),
    ERR_SSL_CLIENT_AUTH_CERT_NEEDED(-110),
    ERR_TUNNEL_CONNECTION_FAILED(-111),
    ERR_NO_SSL_VERSIONS_ENABLED(-112),
    ERR_SSL_VERSION_OR_CIPHER_MISMATCH(-113),
    ERR_SSL_RENEGOTIATION_REQUESTED(-114),
    ERR_CERT_COMMON_NAME_INVALID(-200),
    ERR_CERT_BEGIN(-200),
    ERR_CERT_DATE_INVALID(-201),
    ERR_CERT_AUTHORITY_INVALID(-202),
    ERR_CERT_CONTAINS_ERRORS(-203),
    ERR_CERT_NO_REVOCATION_MECHANISM(-204),
    ERR_CERT_UNABLE_TO_CHECK_REVOCATION(-205),
    ERR_CERT_REVOKED(-206),
    ERR_CERT_INVALID(-207),
    ERR_CERT_WEAK_SIGNATURE_ALGORITHM(-208),
    ERR_CERT_NON_UNIQUE_NAME(-210),
    ERR_CERT_WEAK_KEY(-211),
    ERR_CERT_NAME_CONSTRAINT_VIOLATION(-212),
    ERR_CERT_VALIDITY_TOO_LONG(-213),
    ERR_CERT_END(-213),
    ERR_INVALID_URL(-300),
    ERR_DISALLOWED_URL_SCHEME(-301),
    ERR_UNKNOWN_URL_SCHEME(-302),
    ERR_TOO_MANY_REDIRECTS(-310),
    ERR_UNSAFE_REDIRECT(-311),
    ERR_UNSAFE_PORT(-312),
    ERR_INVALID_RESPONSE(-320),
    ERR_INVALID_CHUNKED_ENCODING(-321),
    ERR_METHOD_NOT_SUPPORTED(-322),
    ERR_UNEXPECTED_PROXY_AUTH(-323),
    ERR_EMPTY_RESPONSE(-324),
    ERR_RESPONSE_HEADERS_TOO_BIG(-325),
    ERR_CACHE_MISS(-400),
    ERR_INSECURE_RESPONSE(-501),
    ;
    private int nativeInt;

    private cef_errorcode_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }

  public enum cef_window_open_disposition_t implements IntegerEnum {
    WOD_UNKNOWN(0),
    WOD_CURRENT_TAB(1),
    WOD_SINGLETON_TAB(2),
    WOD_NEW_FOREGROUND_TAB(3),
    WOD_NEW_BACKGROUND_TAB(4),
    WOD_NEW_POPUP(5),
    WOD_NEW_WINDOW(6),
    WOD_SAVE_TO_DISK(7),
    WOD_OFF_THE_RECORD(8),
    WOD_IGNORE_ACTION(9),
    ;
    private int nativeInt;

    private cef_window_open_disposition_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }

  public enum cef_transition_type_t implements IntegerEnum {
    TT_LINK(0x0),
    TT_EXPLICIT(0x1),
    TT_AUTO_SUBFRAME(0x3),
    TT_MANUAL_SUBFRAME(0x4),
    TT_FORM_SUBMIT(0x7),
    TT_RELOAD(0x8),
    TT_SOURCE_MASK(0xff),
    TT_BLOCKED_FLAG(0x800000),
    TT_FORWARD_BACK_FLAG(0x1000000),
    TT_CHAIN_START_FLAG(0x10000000),
    TT_CHAIN_END_FLAG(0x20000000),
    TT_CLIENT_REDIRECT_FLAG(0x40000000),
    TT_SERVER_REDIRECT_FLAG(0x80000000),
    TT_IS_REDIRECT_MASK(0xc0000000),
    TT_QUALIFIER_MASK(0xffffff00),
    ;
    private int nativeInt;

    private cef_transition_type_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }
  public enum cef_urlrequest_status_t implements IntegerEnum {
    UR_UNKNOWN(0x0),
    UR_SUCCESS(0x1),
    UR_IO_PENDING(0x2),
    UR_CANCELED(0x3),
    UR_FAILED(0x4),
    ;
    private int nativeInt;

    private cef_urlrequest_status_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }

  public enum cef_process_id_t implements IntegerEnum {
    PID_BROWSER(0),
    PID_RENDERER(1),
    ;
    private int nativeInt;

    private cef_process_id_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }

  public enum cef_jsdialog_type_t implements IntegerEnum {
    JSDIALOGTYPE_ALERT(0x0),
    JSDIALOGTYPE_CONFIRM(0x1),
    JSDIALOGTYPE_PROMPT(0x2),
    ;
    private int nativeInt;

    private cef_jsdialog_type_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }

  public enum cef_focus_source_t implements IntegerEnum {
    FOCUS_SOURCE_NAVIGATION(0),
    FOCUS_SOURCE_SYSTEM(1),
    ;
    private int nativeInt;

    private cef_focus_source_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }
  ///
  /// Popup window features.
  ///
  public static class cef_popup_features_t extends Struct {
    static {
      mapTypeForClosure(cef_popup_features_t.class);
    }

    public Signed32 x = new Signed32();
    public Signed32 xSet = new Signed32();
    public Signed32 y = new Signed32();
    public Signed32 ySet = new Signed32();
    public Signed32 width = new Signed32();
    public Signed32 widthSet = new Signed32();
    public Signed32 height = new Signed32();
    public Signed32 heightSet = new Signed32();
    public Signed32 menuBarVisible = new Signed32();
    public Signed32 statusBarVisible = new Signed32();
    public Signed32 toolBarVisible = new Signed32();
    public Signed32 locationBarVisible = new Signed32();
    public Signed32 scrollbarsVisible = new Signed32();
    public Signed32 resizable = new Signed32();
    public Signed32 fullscreen = new Signed32();
    public Signed32 dialog = new Signed32();

    public cef_popup_features_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to receive string values asynchronously.
  ///
  public static class cef_string_visitor_t extends Struct {
    static {
      mapTypeForClosure(cef_string_visitor_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Method that will be executed.
    ///
    public Function<visit> visit = function(visit.class);

    public static interface visit {
      @Delegate
      void invoke(cef_string_visitor_t self_, cef_string_t string);
    }

    public cef_string_visitor_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Structure to implement for visiting cookie values. The functions of this
  /// structure will always be called on the IO thread.
  ///
  public static class cef_cookie_visitor_t extends Struct {
    static {
      mapTypeForClosure(cef_cookie_visitor_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Method that will be called once for each cookie. |count| is the 0-based
    /// index for the current cookie. |total| is the total number of cookies. Set
    /// |deleteCookie| to true (1) to delete the cookie currently being visited.
    /// Return false (0) to stop visiting cookies. This function may never be
    /// called if no cookies are found.
    ///
    public Function<visit> visit = function(visit.class);

    public static interface visit {
      @Delegate
      int invoke(
          cef_cookie_visitor_t self_,
          cef_cookie_t cookie,
          int count,
          int total,
          @Out int deleteCookie);
    }

    public cef_cookie_visitor_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Structure used to implement browser process callbacks. The functions of this
  /// structure will be called on the browser process main thread unless otherwise
  /// indicated.
  ///
  public static class cef_browser_process_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_browser_process_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called on the browser process UI thread immediately after the CEF context
    /// has been initialized.
    ///
    public Function<on_context_initialized> on_context_initialized =
        function(on_context_initialized.class);
    ///
    /// Called before a child process is launched. Will be called on the browser
    /// process UI thread when launching a render process and on the browser
    /// process IO thread when launching a GPU or plugin process. Provides an
    /// opportunity to modify the child process command line. Do not keep a
    /// reference to |command_line| outside of this function.
    ///
    public Function<on_before_child_process_launch> on_before_child_process_launch =
        function(on_before_child_process_launch.class);
    ///
    /// Called on the browser process IO thread after the main thread has been
    /// created for a new render process. Provides an opportunity to specify extra
    /// information that will be passed to
    /// cef_render_process_handler_t::on_render_thread_created() in the render
    /// process. Do not keep a reference to |extra_info| outside of this function.
    ///
    public Function<on_render_process_thread_created> on_render_process_thread_created =
        function(on_render_process_thread_created.class);
    ///
    /// Return the handler for printing on Linux. If a print handler is not
    /// provided then printing will not be supported on the Linux platform.
    ///
    public Function<get_print_handler> get_print_handler = function(get_print_handler.class);
    ///
    /// Called from any thread when work has been scheduled for the browser process
    /// main (UI) thread. This callback is used in combination with CefSettings.
    /// external_message_pump and cef_do_message_loop_work() in cases where the CEF
    /// message loop must be integrated into an existing application message loop
    /// (see additional comments and warnings on CefDoMessageLoopWork). This
    /// callback should schedule a cef_do_message_loop_work() call to happen on the
    /// main (UI) thread. |delay_ms| is the requested delay in milliseconds. If
    /// |delay_ms| is <= 0 then the call should happen reasonably soon. If
    /// |delay_ms| is > 0 then the call should be scheduled to happen after the
    /// specified delay and any currently pending scheduled call should be
    /// cancelled.
    ///
    public Function<on_schedule_message_pump_work> on_schedule_message_pump_work =
        function(on_schedule_message_pump_work.class);

    public static interface on_context_initialized {
      @Delegate
      void invoke(cef_browser_process_handler_t self_);
    }

    public static interface on_before_child_process_launch {
      @Delegate
      void invoke(cef_browser_process_handler_t self_, jnr.ffi.Pointer command_line);
    }

    public static interface on_render_process_thread_created {
      @Delegate
      void invoke(cef_browser_process_handler_t self_, jnr.ffi.Pointer extra_info);
    }

    public static interface get_print_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_browser_process_handler_t self_);
    }

    public static interface on_schedule_message_pump_work {
      @Delegate
      void invoke(cef_browser_process_handler_t self_, int delay_ms);
    }

    public cef_browser_process_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to handle events related to browser load status. The
  /// functions of this structure will be called on the browser process UI thread
  /// or render process main thread (TID_RENDERER).
  ///
  public static class cef_load_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_load_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called when the loading state has changed. This callback will be executed
    /// twice -- once when loading is initiated either programmatically or by user
    /// action, and once when loading is terminated due to completion, cancellation
    /// of failure. It will be called before any calls to OnLoadStart and after all
    /// calls to OnLoadError and/or OnLoadEnd.
    ///
    public Function<on_loading_state_change> on_loading_state_change =
        function(on_loading_state_change.class);
    ///
    /// Called after a navigation has been committed and before the browser begins
    /// loading contents in the frame. The |frame| value will never be NULL -- call
    /// the is_main() function to check if this frame is the main frame.
    /// |transition_type| provides information about the source of the navigation
    /// and an accurate value is only available in the browser process. Multiple
    /// frames may be loading at the same time. Sub-frames may start or continue
    /// loading after the main frame load has ended. This function will not be
    /// called for same page navigations (fragments, history state, etc.) or for
    /// navigations that fail or are canceled before commit. For notification of
    /// overall browser load status use OnLoadingStateChange instead.
    ///
    public Function<on_load_start> on_load_start = function(on_load_start.class);
    ///
    /// Called when the browser is done loading a frame. The |frame| value will
    /// never be NULL -- call the is_main() function to check if this frame is the
    /// main frame. Multiple frames may be loading at the same time. Sub-frames may
    /// start or continue loading after the main frame load has ended. This
    /// function will not be called for same page navigations (fragments, history
    /// state, etc.) or for navigations that fail or are canceled before commit.
    /// For notification of overall browser load status use OnLoadingStateChange
    /// instead.
    ///
    public Function<on_load_end> on_load_end = function(on_load_end.class);
    ///
    /// Called when a navigation fails or is canceled. This function may be called
    /// by itself if before commit or in combination with OnLoadStart/OnLoadEnd if
    /// after commit. |errorCode| is the error code number, |errorText| is the
    /// error text and |failedUrl| is the URL that failed to load. See
    /// net\base\net_error_list.h for complete descriptions of the error codes.
    ///
    public Function<on_load_error> on_load_error = function(on_load_error.class);

    public static interface on_loading_state_change {
      @Delegate
      void invoke(
          cef_load_handler_t self_,
          jnr.ffi.Pointer browser,
          int isLoading,
          int canGoBack,
          int canGoForward);
    }

    public static interface on_load_start {
      @Delegate
      void invoke(
          cef_load_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          cef_transition_type_t transition_type);
    }

    public static interface on_load_end {
      @Delegate
      void invoke(
          cef_load_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          int httpStatusCode);
    }

    public static interface on_load_error {
      @Delegate
      void invoke(
          cef_load_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          cef_errorcode_t errorCode,
          cef_string_t errorText,
          cef_string_t failedUrl);
    }

    public cef_load_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to provide handler implementations. Methods will be
  /// called by the process and/or thread indicated.
  ///
  public static class cef_app_t extends Struct {
    static {
      mapTypeForClosure(cef_app_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Provides an opportunity to view and/or modify command-line arguments before
    /// processing by CEF and Chromium. The |process_type| value will be NULL for
    /// the browser process. Do not keep a reference to the cef_command_line_t
    /// object passed to this function. The CefSettings.command_line_args_disabled
    /// value can be used to start with an NULL command-line object. Any values
    /// specified in CefSettings that equate to command-line arguments will be set
    /// before this function is called. Be cautious when using this function to
    /// modify command-line arguments for non-browser processes as this may result
    /// in undefined behavior including crashes.
    ///
    public Function<on_before_command_line_processing> on_before_command_line_processing =
        function(on_before_command_line_processing.class);
    ///
    /// Provides an opportunity to register custom schemes. Do not keep a reference
    /// to the |registrar| object. This function is called on the main thread for
    /// each process and the registered schemes should be the same across all
    /// processes.
    ///
    public Function<on_register_custom_schemes> on_register_custom_schemes =
        function(on_register_custom_schemes.class);
    ///
    /// Return the handler for resource bundle events. If
    /// CefSettings.pack_loading_disabled is true (1) a handler must be returned.
    /// If no handler is returned resources will be loaded from pack files. This
    /// function is called by the browser and render processes on multiple threads.
    ///
    public Function<get_resource_bundle_handler> get_resource_bundle_handler =
        function(get_resource_bundle_handler.class);
    ///
    /// Return the handler for functionality specific to the browser process. This
    /// function is called on multiple threads in the browser process.
    ///
    public Function<get_browser_process_handler> get_browser_process_handler =
        function(get_browser_process_handler.class);
    ///
    /// Return the handler for functionality specific to the render process. This
    /// function is called on the render process main thread.
    ///
    public Function<get_render_process_handler> get_render_process_handler =
        function(get_render_process_handler.class);

    public static interface on_before_command_line_processing {
      @Delegate
      void invoke(cef_app_t self_, cef_string_t process_type, jnr.ffi.Pointer command_line);
    }

    public static interface on_register_custom_schemes {
      @Delegate
      void invoke(cef_app_t self_, jnr.ffi.Pointer registrar);
    }

    public static interface get_resource_bundle_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_app_t self_);
    }

    public static interface get_browser_process_handler {
      @Delegate
      cef_browser_process_handler_t invoke(cef_app_t self_);
    }

    public static interface get_render_process_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_app_t self_);
    }

    public cef_app_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to handle events related to browser display state.
  /// The functions of this structure will be called on the UI thread.
  ///
  public static class cef_display_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_display_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called when a frame's address has changed.
    ///
    public Function<on_address_change> on_address_change = function(on_address_change.class);
    ///
    /// Called when the page title changes.
    ///
    public Function<on_title_change> on_title_change = function(on_title_change.class);
    ///
    /// Called when the page icon changes.
    ///
    public Function<on_favicon_urlchange> on_favicon_urlchange =
        function(on_favicon_urlchange.class);
    ///
    /// Called when web content in the page has toggled fullscreen mode. If
    /// |fullscreen| is true (1) the content will automatically be sized to fill
    /// the browser content area. If |fullscreen| is false (0) the content will
    /// automatically return to its original size and position. The client is
    /// responsible for resizing the browser if desired.
    ///
    public Function<on_fullscreen_mode_change> on_fullscreen_mode_change =
        function(on_fullscreen_mode_change.class);
    ///
    /// Called when the browser is about to display a tooltip. |text| contains the
    /// text that will be displayed in the tooltip. To handle the display of the
    /// tooltip yourself return true (1). Otherwise, you can optionally modify
    /// |text| and then return false (0) to allow the browser to display the
    /// tooltip. When window rendering is disabled the application is responsible
    /// for drawing tooltips and the return value is ignored.
    ///
    public Function<on_tooltip> on_tooltip = function(on_tooltip.class);
    ///
    /// Called when the browser receives a status message. |value| contains the
    /// text that will be displayed in the status message.
    ///
    public Function<on_status_message> on_status_message = function(on_status_message.class);
    ///
    /// Called to display a console message. Return true (1) to stop the message
    /// from being output to the console.
    ///
    public Function<on_console_message> on_console_message = function(on_console_message.class);

    public static interface on_address_change {
      @Delegate
      void invoke(
          cef_display_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          cef_string_t url);
    }

    public static interface on_title_change {
      @Delegate
      void invoke(cef_display_handler_t self_, jnr.ffi.Pointer browser, cef_string_t title);
    }

    public static interface on_favicon_urlchange {
      @Delegate
      void invoke(cef_display_handler_t self_, jnr.ffi.Pointer browser, jnr.ffi.Pointer icon_urls);
    }

    public static interface on_fullscreen_mode_change {
      @Delegate
      void invoke(cef_display_handler_t self_, jnr.ffi.Pointer browser, int fullscreen);
    }

    public static interface on_tooltip {
      @Delegate
      int invoke(cef_display_handler_t self_, jnr.ffi.Pointer browser, cef_string_t text);
    }

    public static interface on_status_message {
      @Delegate
      void invoke(cef_display_handler_t self_, jnr.ffi.Pointer browser, cef_string_t value);
    }

    public static interface on_console_message {
      @Delegate
      int invoke(
          cef_display_handler_t self_,
          jnr.ffi.Pointer browser,
          cef_string_t message,
          cef_string_t source,
          int line);
    }

    public cef_display_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to handle events related to focus. The functions of
  /// this structure will be called on the UI thread.
  ///
  public static class cef_focus_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_focus_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called when the browser component is about to loose focus. For instance, if
    /// focus was on the last HTML element and the user pressed the TAB key. |next|
    /// will be true (1) if the browser is giving focus to the next component and
    /// false (0) if the browser is giving focus to the previous component.
    ///
    public Function<on_take_focus> on_take_focus = function(on_take_focus.class);
    ///
    /// Called when the browser component is requesting focus. |source| indicates
    /// where the focus request is originating from. Return false (0) to allow the
    /// focus to be set or true (1) to cancel setting the focus.
    ///
    public Function<on_set_focus> on_set_focus = function(on_set_focus.class);
    ///
    /// Called when the browser component has received focus.
    ///
    public Function<on_got_focus> on_got_focus = function(on_got_focus.class);

    public static interface on_take_focus {
      @Delegate
      void invoke(cef_focus_handler_t self_, jnr.ffi.Pointer browser, int next);
    }

    public static interface on_set_focus {
      @Delegate
      int invoke(cef_focus_handler_t self_, jnr.ffi.Pointer browser, cef_focus_source_t source);
    }

    public static interface on_got_focus {
      @Delegate
      void invoke(cef_focus_handler_t self_, jnr.ffi.Pointer browser);
    }

    public cef_focus_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to handle events related to JavaScript dialogs. The
  /// functions of this structure will be called on the UI thread.
  ///
  public static class cef_jsdialog_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_jsdialog_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be
    /// passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure
    /// and user-friendly display string. The |default_prompt_text| value will be
    /// specified for prompt dialogs only. Set |suppress_message| to true (1) and
    /// return false (0) to suppress the message (suppressing messages is
    /// preferable to immediately executing the callback as this is used to detect
    /// presumably malicious behavior like spamming alert messages in
    /// onbeforeunload). Set |suppress_message| to false (0) and return false (0)
    /// to use the default implementation (the default implementation will show one
    /// modal dialog at a time and suppress any additional dialog requests until
    /// the displayed dialog is dismissed). Return true (1) if the application will
    /// use a custom dialog or if the callback has been executed immediately.
    /// Custom dialogs may be either modal or modeless. If a custom dialog is used
    /// the application must execute |callback| once the custom dialog is
    /// dismissed.
    ///
    public Function<on_jsdialog> on_jsdialog = function(on_jsdialog.class);
    ///
    /// Called to run a dialog asking the user if they want to leave a page. Return
    /// false (0) to use the default dialog implementation. Return true (1) if the
    /// application will use a custom dialog or if the callback has been executed
    /// immediately. Custom dialogs may be either modal or modeless. If a custom
    /// dialog is used the application must execute |callback| once the custom
    /// dialog is dismissed.
    ///
    public Function<on_before_unload_dialog> on_before_unload_dialog =
        function(on_before_unload_dialog.class);
    ///
    /// Called to cancel any pending dialogs and reset any saved dialog state. Will
    /// be called due to events like page navigation irregardless of whether any
    /// dialogs are currently pending.
    ///
    public Function<on_reset_dialog_state> on_reset_dialog_state =
        function(on_reset_dialog_state.class);
    ///
    /// Called when the default implementation dialog is closed.
    ///
    public Function<on_dialog_closed> on_dialog_closed = function(on_dialog_closed.class);

    public static interface on_jsdialog {
      @Delegate
      int invoke(
          cef_jsdialog_handler_t self_,
          jnr.ffi.Pointer browser,
          cef_string_t origin_url,
          cef_jsdialog_type_t dialog_type,
          cef_string_t message_text,
          cef_string_t default_prompt_text,
          jnr.ffi.Pointer callback,
          int suppress_message);
    }

    public static interface on_before_unload_dialog {
      @Delegate
      int invoke(
          cef_jsdialog_handler_t self_,
          jnr.ffi.Pointer browser,
          cef_string_t message_text,
          int is_reload,
          jnr.ffi.Pointer callback);
    }

    public static interface on_reset_dialog_state {
      @Delegate
      void invoke(cef_jsdialog_handler_t self_, jnr.ffi.Pointer browser);
    }

    public static interface on_dialog_closed {
      @Delegate
      void invoke(cef_jsdialog_handler_t self_, jnr.ffi.Pointer browser);
    }

    public cef_jsdialog_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to handle events related to browser life span. The
  /// functions of this structure will be called on the UI thread unless otherwise
  /// indicated.
  ///
  public static class cef_life_span_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_life_span_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called on the IO thread before a new popup browser is created. The
    /// |browser| and |frame| values represent the source of the popup request. The
    /// |target_url| and |target_frame_name| values indicate where the popup
    /// browser should navigate and may be NULL if not specified with the request.
    /// The |target_disposition| value indicates where the user intended to open
    /// the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
    /// be true (1) if the popup was opened via explicit user gesture (e.g.
    /// clicking a link) or false (0) if the popup opened automatically (e.g. via
    /// the DomContentLoaded event). The |popupFeatures| structure contains
    /// additional information about the requested popup window. To allow creation
    /// of the popup browser optionally modify |windowInfo|, |client|, |settings|
    /// and |no_javascript_access| and return false (0). To cancel creation of the
    /// popup browser return true (1). The |client| and |settings| values will
    /// default to the source browser's values. If the |no_javascript_access| value
    /// is set to false (0) the new browser will not be scriptable and may not be
    /// hosted in the same renderer process as the source browser. Any
    /// modifications to |windowInfo| will be ignored if the parent browser is
    /// wrapped in a cef_browser_view_t. Popup browser creation will be canceled if
    /// the parent browser is destroyed before the popup browser creation completes
    /// (indicated by a call to OnAfterCreated for the popup browser).
    ///
    public Function<on_before_popup> on_before_popup = function(on_before_popup.class);
    ///
    /// Called after a new browser is created. This callback will be the first
    /// notification that references |browser|.
    ///
    public Function<on_after_created> on_after_created = function(on_after_created.class);
    ///
    /// Called when a browser has recieved a request to close. This may result
    /// directly from a call to cef_browser_host_t::*close_browser() or indirectly
    /// if the browser is parented to a top-level window created by CEF and the
    /// user attempts to close that window (by clicking the 'X', for example). The
    /// do_close() function will be called after the JavaScript 'onunload' event
    /// has been fired.
    ///
    /// An application should handle top-level owner window close notifications by
    /// calling cef_browser_host_t::try_close_browser() or
    /// cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
    /// to close immediately (see the examples below). This gives CEF an
    /// opportunity to process the 'onbeforeunload' event and optionally cancel the
    /// close before do_close() is called.
    ///
    /// When windowed rendering is enabled CEF will internally create a window or
    /// view to host the browser. In that case returning false (0) from do_close()
    /// will send the standard close notification to the browser's top-level owner
    /// window (e.g. WM_CLOSE on Windows, performClose: on OS X, "delete_event" on
    /// Linux or cef_window_delegate_t::can_close() callback from Views). If the
    /// browser's host window/view has already been destroyed (via view hierarchy
    /// tear-down, for example) then do_close() will not be called for that browser
    /// since is no longer possible to cancel the close.
    ///
    /// When windowed rendering is disabled returning false (0) from do_close()
    /// will cause the browser object to be destroyed immediately.
    ///
    /// If the browser's top-level owner window requires a non-standard close
    /// notification then send that notification from do_close() and return true
    /// (1).
    ///
    /// The cef_life_span_handler_t::on_before_close() function will be called
    /// after do_close() (if do_close() is called) and immediately before the
    /// browser object is destroyed. The application should only exit after
    /// on_before_close() has been called for all existing browsers.
    ///
    /// The below examples describe what should happen during window close when the
    /// browser is parented to an application-provided top-level window.
    ///
    /// Example 1: Using cef_browser_host_t::try_close_browser(). This is
    /// recommended for clients using standard close handling and windows created
    /// on the browser process UI thread. 1.  User clicks the window close button
    /// which sends a close notification to
    /// the application's top-level window.
    /// 2.  Application's top-level window receives the close notification and
    /// calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
    /// TryCloseBrowser() returns false so the client cancels the window close.
    /// 3.  JavaScript 'onbeforeunload' handler executes and shows the close
    /// confirmation dialog (which can be overridden via
    /// CefJSDialogHandler::OnBeforeUnloadDialog()).
    /// 4.  User approves the close. 5.  JavaScript 'onunload' handler executes. 6.
    /// CEF sends a close notification to the application's top-level window
    /// (because DoClose() returned false by default).
    /// 7.  Application's top-level window receives the close notification and
    /// calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
    /// allows the window close.
    /// 8.  Application's top-level window is destroyed. 9.  Application's
    /// on_before_close() handler is called and the browser object
    /// is destroyed.
    /// 10. Application exits by calling cef_quit_message_loop() if no other
    /// browsers
    /// exist.
    ///
    /// Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
    /// implementing the do_close() callback. This is recommended for clients using
    /// non-standard close handling or windows that were not created on the browser
    /// process UI thread. 1.  User clicks the window close button which sends a
    /// close notification to
    /// the application's top-level window.
    /// 2.  Application's top-level window receives the close notification and:
    /// A. Calls CefBrowserHost::CloseBrowser(false).
    /// B. Cancels the window close.
    /// 3.  JavaScript 'onbeforeunload' handler executes and shows the close
    /// confirmation dialog (which can be overridden via
    /// CefJSDialogHandler::OnBeforeUnloadDialog()).
    /// 4.  User approves the close. 5.  JavaScript 'onunload' handler executes. 6.
    /// Application's do_close() handler is called. Application will:
    /// A. Set a flag to indicate that the next close attempt will be allowed.
    /// B. Return false.
    /// 7.  CEF sends an close notification to the application's top-level window.
    /// 8.  Application's top-level window receives the close notification and
    /// allows the window to close based on the flag from #6B.
    /// 9.  Application's top-level window is destroyed. 10. Application's
    /// on_before_close() handler is called and the browser object
    /// is destroyed.
    /// 11. Application exits by calling cef_quit_message_loop() if no other
    /// browsers
    /// exist.
    ///
    public Function<do_close> do_close = function(do_close.class);
    ///
    /// Called just before a browser is destroyed. Release all references to the
    /// browser object and do not attempt to execute any functions on the browser
    /// object after this callback returns. This callback will be the last
    /// notification that references |browser|. See do_close() documentation for
    /// additional usage information.
    ///
    public Function<on_before_close> on_before_close = function(on_before_close.class);

    public static interface on_before_popup {
      @Delegate
      int invoke(
          cef_life_span_handler_t self_,
          @Direct jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          cef_string_t target_url,
          cef_string_t target_frame_name,
          cef_window_open_disposition_t target_disposition,
          int user_gesture,
          cef_popup_features_t popupFeatures,
          @Out jnr.ffi.Pointer windowInfo,
          @Out jnr.ffi.Pointer client,
          @Out jnr.ffi.Pointer settings,
          @Out int no_javascript_access);
    }

    public static interface on_after_created {
      @Delegate
      void invoke(cef_life_span_handler_t self_, @Direct jnr.ffi.Pointer browser);
    }

    public static interface do_close {
      @Delegate
      int invoke(cef_life_span_handler_t self_, jnr.ffi.Pointer browser);
    }

    public static interface on_before_close {
      @Delegate
      void invoke(cef_life_span_handler_t self_, jnr.ffi.Pointer browser);
    }

    public cef_life_span_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to handle events related to browser requests. The
  /// functions of this structure will be called on the thread indicated.
  ///
  public static class cef_request_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_request_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called on the UI thread before browser navigation. Return true (1) to
    /// cancel the navigation or false (0) to allow the navigation to proceed. The
    /// |request| object cannot be modified in this callback.
    /// cef_load_handler_t::OnLoadingStateChange will be called twice in all cases.
    /// If the navigation is allowed cef_load_handler_t::OnLoadStart and
    /// cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled
    /// cef_load_handler_t::OnLoadError will be called with an |errorCode| value of
    /// ERR_ABORTED.
    ///
    public Function<on_before_browse> on_before_browse = function(on_before_browse.class);
    ///
    /// Called on the UI thread before OnBeforeBrowse in certain limited cases
    /// where navigating a new or different browser might be desirable. This
    /// includes user-initiated navigation that might open in a special way (e.g.
    /// links clicked via middle-click or ctrl + left-click) and certain types of
    /// cross-origin navigation initiated from the renderer process (e.g.
    /// navigating the top-level frame to/from a file URL). The |browser| and
    /// |frame| values represent the source of the navigation. The
    /// |target_disposition| value indicates where the user intended to navigate
    /// the browser based on standard Chromium behaviors (e.g. current tab, new
    /// tab, etc). The |user_gesture| value will be true (1) if the browser
    /// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
    /// it navigated automatically (e.g. via the DomContentLoaded event). Return
    /// true (1) to cancel the navigation or false (0) to allow the navigation to
    /// proceed in the source browser's top-level frame.
    ///
    public Function<on_open_urlfrom_tab> on_open_urlfrom_tab = function(on_open_urlfrom_tab.class);
    ///
    /// Called on the IO thread before a resource request is loaded. The |request|
    /// object may be modified. Return RV_CONTINUE to continue the request
    /// immediately. Return RV_CONTINUE_ASYNC and call cef_request_tCallback::
    /// cont() at a later time to continue or cancel the request asynchronously.
    /// Return RV_CANCEL to cancel the request immediately.
    ///
    ///
    public Function<on_before_resource_load> on_before_resource_load =
        function(on_before_resource_load.class);
    ///
    /// Called on the IO thread before a resource is loaded. To allow the resource
    /// to load normally return NULL. To specify a handler for the resource return
    /// a cef_resource_handler_t object. The |request| object should not be
    /// modified in this callback.
    ///
    public Function<get_resource_handler> get_resource_handler =
        function(get_resource_handler.class);
    ///
    /// Called on the IO thread when a resource load is redirected. The |request|
    /// parameter will contain the old URL and other request-related information.
    /// The |response| parameter will contain the response that resulted in the
    /// redirect. The |new_url| parameter will contain the new URL and can be
    /// changed if desired. The |request| object cannot be modified in this
    /// callback.
    ///
    public Function<on_resource_redirect> on_resource_redirect =
        function(on_resource_redirect.class);
    ///
    /// Called on the IO thread when a resource response is received. To allow the
    /// resource to load normally return false (0). To redirect or retry the
    /// resource modify |request| (url, headers or post body) and return true (1).
    /// The |response| object cannot be modified in this callback.
    ///
    public Function<on_resource_response> on_resource_response =
        function(on_resource_response.class);
    ///
    /// Called on the IO thread to optionally filter resource response content.
    /// |request| and |response| represent the request and response respectively
    /// and cannot be modified in this callback.
    ///
    public Function<get_resource_response_filter> get_resource_response_filter =
        function(get_resource_response_filter.class);
    ///
    /// Called on the IO thread when a resource load has completed. |request| and
    /// |response| represent the request and response respectively and cannot be
    /// modified in this callback. |status| indicates the load completion status.
    /// |received_content_length| is the number of response bytes actually read.
    ///
    public Function<on_resource_load_complete> on_resource_load_complete =
        function(on_resource_load_complete.class);
    ///
    /// Called on the IO thread when the browser needs credentials from the user.
    /// |isProxy| indicates whether the host is a proxy server. |host| contains the
    /// hostname and |port| contains the port number. |realm| is the realm of the
    /// challenge and may be NULL. |scheme| is the authentication scheme used, such
    /// as "basic" or "digest", and will be NULL if the source of the request is an
    /// FTP server. Return true (1) to continue the request and call
    /// cef_auth_callback_t::cont() either in this function or at a later time when
    /// the authentication information is available. Return false (0) to cancel the
    /// request immediately.
    ///
    public Function<get_auth_credentials> get_auth_credentials =
        function(get_auth_credentials.class);
    ///
    /// Called on the IO thread when JavaScript requests a specific storage quota
    /// size via the webkitStorageInfo.requestQuota function. |origin_url| is the
    /// origin of the page making the request. |new_size| is the requested quota
    /// size in bytes. Return true (1) to continue the request and call
    /// cef_request_tCallback::cont() either in this function or at a later time to
    /// grant or deny the request. Return false (0) to cancel the request
    /// immediately.
    ///
    public Function<on_quota_request> on_quota_request = function(on_quota_request.class);
    ///
    /// Called on the UI thread to handle requests for URLs with an unknown
    /// protocol component. Set |allow_os_execution| to true (1) to attempt
    /// execution via the registered OS protocol handler, if any. SECURITY WARNING:
    /// YOU SHOULD USE THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR
    /// OTHER URL ANALYSIS BEFORE ALLOWING OS EXECUTION.
    ///
    public Function<on_protocol_execution> on_protocol_execution =
        function(on_protocol_execution.class);
    ///
    /// Called on the UI thread to handle requests for URLs with an invalid SSL
    /// certificate. Return true (1) and call cef_request_tCallback::cont() either
    /// in this function or at a later time to continue or cancel the request.
    /// Return false (0) to cancel the request immediately. If
    /// CefSettings.ignore_certificate_errors is set all invalid certificates will
    /// be accepted without calling this function.
    ///
    public Function<on_certificate_error> on_certificate_error =
        function(on_certificate_error.class);
    ///
    /// Called on the UI thread when a client certificate is being requested for
    /// authentication. Return false (0) to use the default behavior and
    /// automatically select the first certificate available. Return true (1) and
    /// call cef_select_client_certificate_callback_t::Select either in this
    /// function or at a later time to select a certificate. Do not call Select or
    /// call it with NULL to continue without using any certificate. |isProxy|
    /// indicates whether the host is an HTTPS proxy or the origin server. |host|
    /// and |port| contains the hostname and port of the SSL server. |certificates|
    /// is the list of certificates to choose from; this list has already been
    /// pruned by Chromium so that it only contains certificates from issuers that
    /// the server trusts.
    ///
    public Function<on_select_client_certificate> on_select_client_certificate =
        function(on_select_client_certificate.class);
    ///
    /// Called on the browser process UI thread when a plugin has crashed.
    /// |plugin_path| is the path of the plugin that crashed.
    ///
    public Function<on_plugin_crashed> on_plugin_crashed = function(on_plugin_crashed.class);
    ///
    /// Called on the browser process UI thread when the render view associated
    /// with |browser| is ready to receive/handle IPC messages in the render
    /// process.
    ///
    public Function<on_render_view_ready> on_render_view_ready =
        function(on_render_view_ready.class);
    ///
    /// Called on the browser process UI thread when the render process terminates
    /// unexpectedly. |status| indicates how the process terminated.
    ///
    public Function<on_render_process_terminated> on_render_process_terminated =
        function(on_render_process_terminated.class);

    public static interface on_before_browse {
      @Delegate
      int invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          jnr.ffi.Pointer request,
          int is_redirect);
    }

    public static interface on_open_urlfrom_tab {
      @Delegate
      int invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          cef_string_t target_url,
          cef_window_open_disposition_t target_disposition,
          int user_gesture);
    }

    public static interface on_before_resource_load {
      @Delegate
      cef_return_value_t invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          jnr.ffi.Pointer request,
          jnr.ffi.Pointer callback);
    }

    public static interface get_resource_handler {
      @Delegate
      jnr.ffi.Pointer invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          jnr.ffi.Pointer request);
    }

    public static interface on_resource_redirect {
      @Delegate
      void invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          jnr.ffi.Pointer request,
          jnr.ffi.Pointer response,
          cef_string_t new_url);
    }

    public static interface on_resource_response {
      @Delegate
      int invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          jnr.ffi.Pointer request,
          jnr.ffi.Pointer response);
    }

    public static interface get_resource_response_filter {
      @Delegate
      jnr.ffi.Pointer invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          jnr.ffi.Pointer request,
          jnr.ffi.Pointer response);
    }

    public static interface on_resource_load_complete {
      @Delegate
      void invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          jnr.ffi.Pointer request,
          jnr.ffi.Pointer response,
          cef_urlrequest_status_t status,
          int received_content_length);
    }

    public static interface get_auth_credentials {
      @Delegate
      int invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          int isProxy,
          cef_string_t host,
          int port,
          cef_string_t realm,
          cef_string_t scheme,
          jnr.ffi.Pointer callback);
    }

    public static interface on_quota_request {
      @Delegate
      int invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          cef_string_t origin_url,
          int new_size,
          jnr.ffi.Pointer callback);
    }

    public static interface on_protocol_execution {
      @Delegate
      void invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          cef_string_t url,
          IntByReference allow_os_execution);
    }

    public static interface on_certificate_error {
      @Delegate
      int invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          cef_errorcode_t cert_error,
          cef_string_t request_url,
          jnr.ffi.Pointer ssl_info,
          jnr.ffi.Pointer callback);
    }

    public static interface on_select_client_certificate {
      @Delegate
      int invoke(
          cef_request_handler_t self_,
          jnr.ffi.Pointer browser,
          int isProxy,
          cef_string_t host,
          int port,
          int certificatesCount,
          jnr.ffi.Pointer certificates,
          jnr.ffi.Pointer callback);
    }

    public static interface on_plugin_crashed {
      @Delegate
      void invoke(cef_request_handler_t self_, jnr.ffi.Pointer browser, cef_string_t plugin_path);
    }

    public static interface on_render_view_ready {
      @Delegate
      void invoke(cef_request_handler_t self_, jnr.ffi.Pointer browser);
    }

    public static interface on_render_process_terminated {
      @Delegate
      void invoke(
          cef_request_handler_t self_, jnr.ffi.Pointer browser, cef_termination_status_t status);
    }

    public cef_request_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to provide handler implementations.
  ///
  public static class cef_client_t extends Struct {
    static {
      mapTypeForClosure(cef_client_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Return the handler for context menus. If no handler is provided the default
    /// implementation will be used.
    ///
    public Function<get_context_menu_handler> get_context_menu_handler =
        function(get_context_menu_handler.class);
    ///
    /// Return the handler for dialogs. If no handler is provided the default
    /// implementation will be used.
    ///
    public Function<get_dialog_handler> get_dialog_handler = function(get_dialog_handler.class);
    ///
    /// Return the handler for browser display state events.
    ///
    public Function<get_display_handler> get_display_handler = function(get_display_handler.class);
    ///
    /// Return the handler for download events. If no handler is returned downloads
    /// will not be allowed.
    ///
    public Function<get_download_handler> get_download_handler =
        function(get_download_handler.class);
    ///
    /// Return the handler for drag events.
    ///
    public Function<get_drag_handler> get_drag_handler = function(get_drag_handler.class);
    ///
    /// Return the handler for find result events.
    ///
    public Function<get_find_handler> get_find_handler = function(get_find_handler.class);
    ///
    /// Return the handler for focus events.
    ///
    public Function<get_focus_handler> get_focus_handler = function(get_focus_handler.class);
    ///
    /// Return the handler for geolocation permissions requests. If no handler is
    /// provided geolocation access will be denied by default.
    ///
    public Function<get_geolocation_handler> get_geolocation_handler =
        function(get_geolocation_handler.class);
    ///
    /// Return the handler for JavaScript dialogs. If no handler is provided the
    /// default implementation will be used.
    ///
    public Function<get_jsdialog_handler> get_jsdialog_handler =
        function(get_jsdialog_handler.class);
    ///
    /// Return the handler for keyboard events.
    ///
    public Function<get_keyboard_handler> get_keyboard_handler =
        function(get_keyboard_handler.class);
    ///
    /// Return the handler for browser life span events.
    ///
    public Function<get_life_span_handler> get_life_span_handler =
        function(get_life_span_handler.class);
    ///
    /// Return the handler for browser load status events.
    ///
    public Function<get_load_handler> get_load_handler = function(get_load_handler.class);
    ///
    /// Return the handler for off-screen rendering events.
    ///
    public Function<get_render_handler> get_render_handler = function(get_render_handler.class);
    ///
    /// Return the handler for browser request events.
    ///
    public Function<get_request_handler> get_request_handler = function(get_request_handler.class);
    ///
    /// Called when a new message is received from a different process. Return true
    /// (1) if the message was handled or false (0) otherwise. Do not keep a
    /// reference to or attempt to access the message outside of this callback.
    ///
    public Function<on_process_message_received> on_process_message_received =
        function(on_process_message_received.class);

    public static interface get_context_menu_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_dialog_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_display_handler {
      @Delegate
      cef_display_handler_t invoke(cef_client_t self_);
    }

    public static interface get_download_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_drag_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_find_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_focus_handler {
      @Delegate
      cef_focus_handler_t invoke(cef_client_t self_);
    }

    public static interface get_geolocation_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_jsdialog_handler {
      @Delegate
      cef_jsdialog_handler_t invoke(cef_client_t self_);
    }

    public static interface get_keyboard_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_life_span_handler {
      @Delegate
      cef_life_span_handler_t invoke(cef_client_t self_);
    }

    public static interface get_load_handler {
      @Delegate
      cef_load_handler_t invoke(cef_client_t self_);
    }

    public static interface get_render_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_request_handler {
      @Delegate
      cef_request_handler_t invoke(cef_client_t self_);
    }

    public static interface on_process_message_received {
      @Delegate
      int invoke(
          cef_client_t self_,
          jnr.ffi.Pointer browser,
          cef_process_id_t source_process,
          jnr.ffi.Pointer message);
    }

    public cef_client_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
}
